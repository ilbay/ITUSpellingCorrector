package tr.edu.itu.bb.spellcorrection.trie;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;

import tr.edu.itu.bb.spellcorrection.levenshtein.CandidateWord;
import tr.edu.itu.bb.spellcorrection.levenshtein.Rule;

public class CandidateSearcher {

	private CandidateWord word;
	private Map<Byte, List<Rule>> rulesAvailable;
	private Trie vocabularyTrie;

	public CandidateSearcher(CandidateWord word, Trie vocabularyTrie, Map<Byte, List<Rule>> rulesAvailable)
	{
		this.word = word;
		this.rulesAvailable = rulesAvailable;
		this.vocabularyTrie = vocabularyTrie;
	}
	
	public TreeSet<CandidateWord> buildCandidateList(int maxCandidate)
	{
		TreeSet<CandidateWord> candidateList = new TreeSet<>();
		Node rootNode = this.vocabularyTrie.getRootNode();
		
		Stack<DecisionPoint> decisionPointStack = new Stack<>();
		/**
		 * Used to find if there are multiple decision points that intersect at the same node.
		 * If yes, then prune the decision point that has the smallest weight
		 */
		Map<Node, DecisionPoint> decisionPointSet = new HashMap<>();

		DecisionPoint initialDecisionPoint = new DecisionPoint(this.word, 0, rootNode);
		decisionPointStack.push(initialDecisionPoint);
		decisionPointSet.put(rootNode, initialDecisionPoint);
		
		//min weight karşılaştırması daha implemente edilmedi.
		
		while(!decisionPointStack.isEmpty())
		{
			DecisionPoint currentDecisionPoint = decisionPointStack.pop();
			
			CandidateWord currentCandidateWord = currentDecisionPoint.getCandidateWord();
			int currentIndex = currentDecisionPoint.getIndex();
			Node currentNode = currentDecisionPoint.getNode();
			
			if(decisionPointSet.get(currentNode) != currentDecisionPoint)
			{
				continue;
			}
			
			if(currentNode.getSubNode(currentCandidateWord.getCandidateWord().charAt(currentIndex)) != null)
			{
				DecisionPoint newDecisionPoint = new DecisionPoint(currentCandidateWord, currentIndex+1, currentNode.getSubNode(currentCandidateWord.getCandidateWord().charAt(currentIndex)));
				if(this.putNewDecisionPoint(newDecisionPoint, decisionPointSet))
				{
					decisionPointStack.add(newDecisionPoint);
				}
			}
			
			List<Rule> rules = this.rulesAvailable.get(currentIndex);
			if(rules == null)
			{
				continue;
			}
			
			for(Rule rule : rules)
			{
				CandidateWord newCandidateWord = currentCandidateWord.applyRule(rule);
				if( candidateList.size() >= maxCandidate && candidateList.first().getTotalWeight() > newCandidateWord.getTotalWeight())
				{
					break;
				}
				try
				{
					Node newCandidateCurrentNode = currentNode;
					for(char c : rule.getAfter().toCharArray())
					{
						newCandidateCurrentNode = newCandidateCurrentNode.getSubNode(c);
					}
					if(!newCandidateCurrentNode.getOutput().equals(""))
					{
						if(candidateList.size() == maxCandidate)
						{
							candidateList.remove(candidateList.first());
						}
						candidateList.add(newCandidateWord.buildCandidateWord());
					}
					if(newCandidateCurrentNode != null) //TODO: This control seems not necessary
					{
						DecisionPoint newDecisionPoint = new DecisionPoint(newCandidateWord, currentIndex+rule.getBefore().length(), newCandidateCurrentNode);
						if(this.putNewDecisionPoint(newDecisionPoint, decisionPointSet))
						{
							decisionPointStack.push(newDecisionPoint);
						}
					}
				}
				catch(NullPointerException ex)
				{
					// Occured since probably the word generated by applying new word does not exist in vocabulary trie
					// No extra work is required.
				}
			}
		}

		return candidateList;
	}
	
	private boolean putNewDecisionPoint(DecisionPoint decisionPoint, Map<Node, DecisionPoint> decisionPointSet)
	{
		DecisionPoint existingDecisionPoint = decisionPointSet.get(decisionPoint.getNode());
		if( (existingDecisionPoint != null && existingDecisionPoint.getCandidateWord().getTotalWeight() < decisionPoint.getCandidateWord().getTotalWeight())
			|| existingDecisionPoint == null)
		{
			decisionPointSet.put(decisionPoint.getNode(), decisionPoint);
			return true;
		}
		return false;
	}
	
	private class DecisionPoint{
		private Node node;
		private int index;
		private CandidateWord candidateWord;
		
		public DecisionPoint(CandidateWord candidateWord, int index, Node node)
		{
			this.candidateWord = candidateWord;
			this.index = index;
			this.node = node;
		}
		
		public int hashCode()
		{
			return node.hashCode() * this.index + this.index;
		}
		
		public boolean equals(Object o)
		{
			DecisionPoint dp = (DecisionPoint)o;
			return dp.node == this.node && dp.index == this.index;
		}

		public Node getNode() {
			return node;
		}

		public void setNode(Node node) {
			this.node = node;
		}

		public int getIndex() {
			return index;
		}

		public void setIndex(int index) {
			this.index = index;
		}

		public CandidateWord getCandidateWord() {
			return candidateWord;
		}

		public void setCandidateWord(CandidateWord candidateWord) {
			this.candidateWord = candidateWord;
		}
	}
	
}
